"""
meta_ir_execute_recommendations.py
--------------------------------------

Execute all recommendations generated by META_IR_Predictor
(independent, model_first, and strategy_first) on the same dataset.

Applies each recommended (model, strategy) pair from:
  - recommendation_independent.csv
  - recommendation_model_first.csv
  - recommendation_strategy_first.csv
"""

import os
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.ensemble import BaggingRegressor, RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.neural_network import MLPRegressor
from sklearn.svm import SVR
from xgboost import XGBRegressor
import ImbalancedLearningRegression as iblr
import smogn
import resreg

# Importando o cálculo de phi
from ImbalancedLearningRegression.phi import phi
from ImbalancedLearningRegression.phi_ctrl_pts import phi_ctrl_pts

# Import SERA metric
from metrics import sera


# ============================================================
# Apply balancing strategy (same as META_IR)
# ============================================================
def apply_balancing(train, strategy):
    print(f"Applying balancing strategy: {strategy}")

    if strategy == "GN":
        train = iblr.gn(data=train, y=train.columns[0], rel_thres=0.8)
    elif strategy == "RO":
        train = iblr.ro(data=train, y=train.columns[0], rel_thres=0.8)
    elif strategy == "RU":
        train = iblr.random_under(data=train, y=train.columns[0], rel_thres=0.8)
    elif strategy == "SG":
        train = train.dropna()
        train = smogn.smoter(data=train, y=train.columns[0], rel_xtrm_type='high', rel_thres=0.8)
        train = train.dropna()
    elif strategy == "SMT":
        train = iblr.smote(data=train, y=train.columns[0], rel_thres=0.8)
    elif strategy == "WC":
        X_train = train.drop([train.columns[0]], axis=1)
        y_train = train[train.columns[0]]
        relevance = resreg.pdf_relevance(y_train)
        X_wercs, y_wercs = resreg.wercs(X_train, y_train, relevance)
        trainWC = np.column_stack((y_wercs, X_wercs))
        train = pd.DataFrame(trainWC)
    elif strategy in ["None", "NONE", "NA"]:
        print("No balancing applied.")
    else:
        print(f"Unknown strategy '{strategy}', skipping balancing.")

    print(f"Balancing complete. Final shape: {train.shape}")
    return train


# ============================================================
# Map short code to model
# ============================================================
def get_model_by_code(code):
    print(f"Selected model: {code}")
    code = code.strip().upper()

    if code == "BG":
        return BaggingRegressor(random_state=42)
    elif code == "DT":
        return DecisionTreeRegressor(random_state=42)
    elif code == "MLP":
        return MLPRegressor(random_state=42, max_iter=500)
    elif code == "RF":
        return RandomForestRegressor(random_state=42)
    elif code == "SVR":
        return SVR()
    elif code == "XG":
        return XGBRegressor(random_state=42, verbosity=0)
    else:
        print("Unknown model code. Defaulting to RandomForestRegressor.")
        return RandomForestRegressor(random_state=42)


# ============================================================
# Evaluate regression (com cálculo de phi e SERA)
# ============================================================
def evaluate(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    r2 = r2_score(y_true, y_pred)

    # Calculando phi (relevância)
    try:
        y_true_series = pd.Series(y_true)
        ctrl_pts = phi_ctrl_pts(y_true_series)
        phi_trues = phi(y_true_series, ctrl_pts)
        sera_value = sera(y_true_series, y_pred, phi_trues=phi_trues, pl=False)
    except Exception as e:
        print(f"Warning: could not compute SERA with phi ({e})")
        sera_value = np.nan

    print(f"MAE={mae:.4f} | RMSE={rmse:.4f} | R²={r2:.4f} | SERA={sera_value:.4f}")
    return mae, rmse, r2, sera_value


# ============================================================
# Main execution for all recommendation files
# ============================================================
if __name__ == "__main__":
    dataset_path = "/content/machine_CPU.csv"
    print(f"Loading dataset from {dataset_path}...")
    df = pd.read_csv(dataset_path)
    print(f"Dataset loaded. Shape: {df.shape}")

    # Prepare dataset
    target_col = df.columns[-1]
    X = df.drop(columns=[target_col, df.columns[0]])
    y = df[target_col]
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    # Combine for balancing
    train_df = pd.concat([y_train.reset_index(drop=True), X_train.reset_index(drop=True)], axis=1)

    # Define all possible recommendation files
    rec_files = {
        "independent": "recommendation_independent.csv",
        "model_first": "recommendation_model_first.csv",
        "strategy_first": "recommendation_strategy_first.csv"
    }

    results_list = []

    for mode, rec_path in rec_files.items():
        print(f"\n==============================")
        print(f"Processing recommendation: {mode}")
        print(f"==============================")

        if not os.path.exists(rec_path):
            print(f"File not found: {rec_path}")
            continue

        recommendation = pd.read_csv(rec_path)

        # Handle possible columns
        model_code = recommendation.columns[0]
        strategy_col = recommendation.columns[-1]

        model_name = str(recommendation[model_code].iloc[0])
        strategy_name = str(recommendation[strategy_col].iloc[0])

        print(f"Model: {model_name} | Strategy: {strategy_name}")

        # Apply balancing
        balanced_train = apply_balancing(train_df.copy(), strategy_name)

        # Separate again
        y_bal = balanced_train.iloc[:, 0]
        X_bal = balanced_train.iloc[:, 1:]

        # Train model
        model = get_model_by_code(model_name)
        print("Training model...")
        model.fit(X_bal, y_bal)
        print("Model trained successfully.")

        # Evaluate
        y_pred = model.predict(X_test)
        mae, rmse, r2, sera_val = evaluate(y_test, y_pred)

        results_list.append({
            "Mode": mode,
            "Model": model_name,
            "Strategy": strategy_name,
            "MAE": mae,
            "RMSE": rmse,
            "R2": r2,
            "SERA": sera_val
        })

    # Save all results
    results_df = pd.DataFrame(results_list)
    results_path = "/content/evaluation_results_all.csv"
    results_df.to_csv(results_path, index=False)

    print("\nAll recommendations executed successfully!")
    print(f"Results saved to: {results_path}")
    print(results_df)

def execute_all(dataset_path, rec_dir, output_path):
    df = pd.read_csv(dataset_path)
    target_col = df.columns[-1]
    X = df.drop(columns=[target_col, df.columns[0]])
    y = df[target_col]
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
    train_df = pd.concat([y_train.reset_index(drop=True), X_train.reset_index(drop=True)], axis=1)

    rec_files = {
        "independent": os.path.join(rec_dir, "recommendation_independent.csv"),
        "model_first": os.path.join(rec_dir, "recommendation_model_first.csv"),
        "strategy_first": os.path.join(rec_dir, "recommendation_strategy_first.csv"),
    }

    results = []
    for mode, rec_path in rec_files.items():
        if not os.path.exists(rec_path):
            continue
        recommendation = pd.read_csv(rec_path)
        model_name = str(recommendation.iloc[0, 0])
        strategy_name = str(recommendation.iloc[0, -1])

        balanced_train = apply_balancing(train_df.copy(), strategy_name)
        y_bal, X_bal = balanced_train.iloc[:, 0], balanced_train.iloc[:, 1:]
        model = get_model_by_code(model_name)
        model.fit(X_bal, y_bal)
        y_pred = model.predict(X_test)
        mae, rmse, r2, sera_val = evaluate(y_test, y_pred)
        results.append([mode, model_name, strategy_name, mae, rmse, r2, sera_val])

    results_df = pd.DataFrame(results, columns=["Mode", "Model", "Strategy", "MAE", "RMSE", "R2", "SERA"])
    results_df.to_csv(output_path, index=False)
    print(f"Results saved to {output_path}")
